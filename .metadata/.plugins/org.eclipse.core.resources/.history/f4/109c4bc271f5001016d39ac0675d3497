/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : MPU6050 - CDC Buffer Fix
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "mpu6050.h"
#include "usbd_cdc_if.h"
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */

/* Private variables ---------------------------------------------------------*/
extern I2C_HandleTypeDef hi2c1; // i2c1 handle (defined in another file)

/* USER CODE BEGIN PV */
MPU6050_Data mpu_data;     // Structure to hold MPU6050 data
char msg[100];             // Buffer for terminal messages
uint8_t usb_ready = 0;     // Is USB ready? 0 = no, 1 = yes
uint32_t counter = 0;      // Counter for number of data reads
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
void MX_I2C1_Init(void);
void MX_USB_DEVICE_Init(void);

/* USER CODE BEGIN PFP */
// Safe CDC transmission
void CDC_Send(char *text)
{
    uint16_t len = strlen(text); // Calculate message length
    uint8_t result = CDC_Transmit_FS((uint8_t*)text, len); // Send via USB

    // If USB is busy, wait and retry
    while(result == USBD_BUSY) {
        HAL_Delay(10);
        result = CDC_Transmit_FS((uint8_t*)text, len);
    }
    HAL_Delay(10); // Wait 10 ms after transmission
}
/* USER CODE END PFP */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_USB_DEVICE_Init();

  /* USER CODE BEGIN 2 */

  HAL_Delay(5000); // Wait 5 seconds until USB is fully ready

  CDC_Send("\r\n\r\n*** MPU6050 TEST START ***\r\n\r\n"); // Initial message

  // I2C scan
  CDC_Send("Scanning I2C...\r\n");
  uint8_t found = 0;
  for (uint8_t i = 1; i < 128; i++) // Scan all I2C addresses from 1 to 127
  {
      if (HAL_I2C_IsDeviceReady(&hi2c1, i << 1, 1, 10) == HAL_OK) // Check if device exists at this address
      {
          sprintf(msg, "Found: 0x%02X\r\n", i);
          CDC_Send(msg);
          found = 1;
      }
  }

  // If no device is found
  if (!found)
  {
      CDC_Send("ERROR: No I2C devices!\r\n");
      CDC_Send("Check wiring:\r\n");
      CDC_Send("VCC->3.3V GND->GND\r\n");
      CDC_Send("SCL->PB6 SDA->PB7\r\n");
      while(1)
      {
          HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // Toggle LED every 100 ms
          HAL_Delay(100);
      }
  }

  // Initialize MPU6050
  CDC_Send("\r\nInit MPU6050...\r\n");

  uint8_t init_result = MPU6050_Init(&hi2c1);

  if (init_result == 0)
  {
      CDC_Send("MPU6050 OK!\r\n");
      usb_ready = 1; // Ready to read data
  }
  // Error handling
  else
  {
      sprintf(msg, "MPU6050 FAILED! Error code: %d\r\n", init_result);
      CDC_Send(msg);
      CDC_Send("Codes: 1=PWR_MGMT, 2=WHO_AM_I read, 3=Wrong ID, 4=ACCEL_CFG\r\n");

      // Manually read WHO_AM_I register
      uint8_t whoami;
      HAL_StatusTypeDef ret = HAL_I2C_Mem_Read(
          &hi2c1,
          0xD0,   // MPU6050 I2C address
          0x75,   // WHO_AM_I register address
          1,
          &whoami,
          1,
          1000
      );

      if (ret == HAL_OK)
      {
          sprintf(msg, "WHO_AM_I read OK\r\n");
          CDC_Send(msg);
      }
      else
      {
          sprintf(msg, "WHO_AM_I read FAILED! HAL status: %d\r\n", ret);
          CDC_Send(msg);
      }

      while(1)
      {
          HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
          HAL_Delay(250);
      }
  }

  HAL_Delay(1000);
  CDC_Send("\r\n--- DATA START ---\r\n");

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */

    if (usb_ready)
    {
        // Debug: read raw accelerometer data
        uint8_t test_data[6];
        HAL_StatusTypeDef ret =
            HAL_I2C_Mem_Read(&hi2c1, 0xD0, 0x3B, 1, test_data, 6, 1000);

        if (ret != HAL_OK)
        {
            sprintf(msg, "%lu: I2C READ ERROR! Status=%d\r\n", counter++, ret);
            CDC_Send(msg);
        }
        else
        {
            // Read accelerometer data
            MPU6050_Read_Accel(&hi2c1, &mpu_data);

            // Convert to g units
            float ax = (float)mpu_data.accel_x / 16384.0f;
            float ay = (float)mpu_data.accel_y / 16384.0f;
            float az = (float)mpu_data.accel_z / 16384.0f;

            // Convert float to int for sprintf printing
            int ax_int = (int)(ax * 100);  // x100 for 2 decimal places
            int ay_int = (int)(ay * 100);
            int az_int = (int)(az * 100);

            // Print raw and converted values
            sprintf(msg,
                    "%lu: Raw[%d,%d,%d] G[%d.%02d,%d.%02d,%d.%02d]\r\n",
                    counter++,
                    mpu_data.accel_x, mpu_data.accel_y, mpu_data.accel_z,
                    ax_int/100, abs(ax_int%100),
                    ay_int/100, abs(ay_int%100),
                    az_int/100, abs(az_int%100));
            CDC_Send(msg);
        }

        // Toggle LED
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
    }

    HAL_Delay(500); // 500 ms (2 reads per second)
  }
  /* USER CODE END 3 */
}
